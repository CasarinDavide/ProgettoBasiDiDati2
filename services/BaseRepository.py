import datetime
from typing import Optional, List, Type, TypeVar, Generic, Any, Dict, Sequence
from flask import jsonify, Response
from sqlalchemy.orm import Session, joinedload
from sqlalchemy.exc import SQLAlchemyError
from sqlalchemy import or_, and_, inspect, Row
from System import engine

T = TypeVar("T")

from sqlalchemy.inspection import inspect

from sqlalchemy.inspection import inspect
from sqlalchemy.orm.state import InstanceState

from typing import Sequence, Any
from datetime import date, time, datetime


def to_json(rows: Sequence[Row[Any]], error: str) -> Response:
    data = []
    for row in rows:
        row_dict = dict(row._mapping)

        for key, value in row_dict.items():
            if isinstance(value, (date, time, datetime)):
                row_dict[key] = str(value)
        data.append(row_dict)

    if data:
        return jsonify(data)
    else:
        return jsonify({ 'error': error })

def to_dict_list(rows: Sequence[Row[Any]]) -> list[dict]:
    """Converte RowMapping in lista di dict serializzabili"""
    data = []
    for row in rows:
        row_dict = dict(row._mapping)
        for key, value in row_dict.items():
            if isinstance(value, (date, time, datetime)):
                row_dict[key] = str(value)
        data.append(row_dict)
    return data

def connection_err() -> Response:
    return jsonify({'error': 'Errore di connessione'})

def model_to_dict(obj, include_relationships=True, backrefs=False):
    """Convert SQLAlchemy model instance to dict, avoiding DetachedInstanceError"""
    mapper = inspect(obj.__class__)
    state: InstanceState = inspect(obj)
    data = {}

    # Extract basic columns
    for c in mapper.columns:
        value = getattr(obj, c.key)
        if isinstance(value, (datetime, date, time)):
            data[c.key] = value.isoformat()
        else:
            data[c.key] = value

    if include_relationships:
        for rel in mapper.relationships:
            if not backrefs and rel.back_populates:
                continue

            if rel.key in state.unloaded:
                continue

            value = getattr(obj, rel.key)

            if value is None:
                data[rel.key] = None
            elif rel.uselist:
                # For one-to-many / many-to-many → list of objects
                data[rel.key] = [
                    model_to_dict(item, include_relationships=False) for item in value
                ]
            else:
                # For many-to-one / one-to-one → single object
                data[rel.key] = model_to_dict(value, include_relationships=False)

    return data


class BaseRepository(Generic[T]):

    """
       Classe repository generica per la gestione CRUD (Create, Read, Update, Delete)
       di un modello SQLAlchemy.

       Consente di:
       - Aggiungere record
       - Recuperare record (singoli o multipli)
       - Aggiornare record
       - Eliminare record
       - Eseguire ricerche con filtri dinamici
       - Fornire output in formato compatibile con DataTables (front-end)
   """

    def __init__(self, model: Type[T]):
        """
            Inizializza il repository con un modello SQLAlchemy.
            :param model: Classe del modello (es. Admin, Compagnia, ecc.)
        """

        self.model = model

    def _apply_joins(self, query, joins: Optional[List[Any]] = None):
        """
            Applica dinamicamente join con altre tabelle,
            senza alterare il risultato della query (grazie a joinedload).

            :param query: oggetto Query SQLAlchemy
            :param joins: lista di relazioni da caricare
        """
        if joins:

            for j in joins:
                # joinedload is useful bc doesnt filter row based on join
                # but add information about ext table
                query = query.options(joinedload(j))
        return query

    def add(self, **kwargs) -> Optional[T]:
        """
            Crea e salva un nuovo record nel database.
            Supporta sessioni esterne per gestire transazioni complesse.

            :param kwargs: attributi del modello
            :return: record creato o None in caso di errore

        """

        external_session = kwargs.pop("session", None)
        record = self.model(**kwargs)

        if external_session:
            external_session.add(record)
            return record

        try:
            with Session(engine()) as session:
                session.add(record)
                session.commit()
                session.refresh(record)  # ensures we get autogenerated PKs, etc.
                return record
        except SQLAlchemyError as e:
            try:
                session.rollback()
            except Exception:
                pass
            return None

    def get_all(self, joins: Optional[List[Any]] = None,**kwargs) -> List[T]:
        """
           Recupera tutti i record del modello con eventuali filtri.

           :param joins: lista di relazioni da caricare
           :param kwargs: filtri (colonna=valore)
           :return: lista di record
       """

        with Session(engine()) as session:
            query = session.query(self.model)
            if joins:
                for j in joins:
                    query = query.options(joinedload(j))

            filters = [getattr(self.model, key) == value for key, value in kwargs.items()]
            query = query.filter(and_(*filters))

            return query.all()

    def get_by_id(self, obj_id, pk_field: str = "id", joins: Optional[List[Any]] = None) -> Optional[T]:

        """
            Recupera un record per chiave primaria.

            :param obj_id: valore della PK
            :param pk_field: nome del campo PK (default "id")
            :param joins: relazioni opzionali da caricare
            :return: record o None
        """

        with Session(engine()) as session:
            query = session.query(self.model)
            if joins:
                for j in joins:
                    query = query.options(joinedload(j))
            query = query.filter(getattr(self.model, pk_field) == obj_id)
            print(str(query.statement.compile(compile_kwargs={"literal_binds": True})))
            return query.first()

    def update(self, obj_id, pk_field: str = "id", **kwargs) -> bool:

        """
           Aggiorna un record esistente.

           :param obj_id: valore della PK
           :param pk_field: nome del campo PK
           :param kwargs: valori da aggiornare
           :return: True se aggiornato, False altrimenti
       """

        with Session(engine()) as session:
            obj = session.query(self.model).filter(getattr(self.model, pk_field) == obj_id).first()
            query = session.query(self.model).filter(getattr(self.model, pk_field) == obj_id)
            print(str(query.statement.compile(compile_kwargs={"literal_binds": True})))

            if not obj:
                return False
            for key, value in kwargs.items():
                setattr(obj, key, value)


            session.commit()
            return True

    def delete(self, obj_id, pk_field: str = "id") -> bool:
        """
            Elimina un record dal database.

            :param obj_id: valore della PK
            :param pk_field: nome del campo PK
            :return: True se eliminato, False altrimenti
        """

        with Session(engine()) as session:
            obj = session.query(self.model).filter(getattr(self.model, pk_field) == obj_id).first()
            if not obj:
                return False
            session.delete(obj)
            session.commit()
            return True

    def get_datatable(
            self,
            draw: int,
            start: int,
            length: int,
            search_value: str,
            search_fields: List[str],
            joins: Optional[List[Any]] = None,
            **kwargs
    ):
        """
            Query generica per DataTables con ricerca, filtro e paginazione.

            :param draw: contatore richieste DataTables
            :param start: offset iniziale
            :param length: numero di record da restituire
            :param search_value: valore di ricerca globale
            :param search_fields: campi in cui cercare
            :param joins: relazioni opzionali da caricare
            :param kwargs: ulteriori filtri
            :return: Response JSON compatibile con DataTables
        """

        with Session(engine()) as session:
            query = session.query(self.model)
            query = self._apply_joins(query, joins)

            records_total = query.count()

            if search_value:
                filters = [
                    getattr(self.model, field).ilike(f"%{search_value}%")
                    for field in search_fields
                ]
                query = query.filter(or_(*filters))


            filters = [getattr(self.model, key) == value
                       for key, value in kwargs.items()
                       if value is not None and not (isinstance(value, str) and value == '')]
            query = query.filter(and_(*filters))

            records_filtered = query.count()
            rows = query.offset(start).limit(length).all()

            # Convert rows to dict
            data = [model_to_dict(r,backrefs = True) for r in rows]

        return jsonify({
            "draw": draw,
            "recordsTotal": records_total,
            "recordsFiltered": records_filtered,
            "data": data
        })

    def search_by_columns(self, joins: Optional[List[Any]] = None, **kwargs) -> Optional[List[T]]:
        """
            Search records by exact column matches + optional joins.
            Example:
                search_by_columns(nome="Test", email="abc@test.com", joins=[OtherModel], session=session)
        """

        # Extract an existing session if provided
        session = kwargs.pop("session", None)

        # Use provided session or create a new one
        owns_session = False

        if session is None:
            session = Session(engine())
            owns_session = True

        try:
            query = session.query(self.model)
            query = self._apply_joins(query, joins)

            filters = [getattr(self.model, key) == value for key, value in kwargs.items()]
            query = query.filter(and_(*filters))

            results = query.all()

            return results

        finally:
            if owns_session:
                session.close()


    def search_single_by_columns(self, joins: Optional[List[Any]] = None, **kwargs) -> Optional[T]:
        """
            Fetch a single record by multiple filters with optional joins.
            Example:
                search_single_by_columns(nome="Test", joins=[OtherModel], session=session)
        """
        session = kwargs.pop("session", None)

        owns_session = False
        if session is None:
            session = Session(engine())
            owns_session = True

        try:
            query = session.query(self.model)
            query = self._apply_joins(query, joins)

            filters = [getattr(self.model, key) == value for key, value in kwargs.items()]
            result = query.filter(and_(*filters)).first()

            return result

        finally:
            if owns_session:
                session.close()

